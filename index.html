<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thomas Chernaik</title>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
            crossorigin="anonymous"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

    <style>
        /* Dark Mode Theme Styles */
        /* Style the body with a dark purple background color for dark mode */
        .dark-mode {
            background-color: #2a2253; /* Dark purple background */
            color: #fff; /* White text color */
        }

        /* Style the navigation menu with light text on a dark purple background */
        .dark-mode nav {
            background-color: #180e2c; /* Darker purple background */
        }

        /* Style the navbar links with larger size and wider spacing */
        .dark-mode nav a {
            color: #fff; /* White text color */
        }

        /* Style the header with a purple background and white text */
        .dark-mode header {
            background-color: #180e2c; /* Even darker purple background */
            color: #fff; /* White text color */
        }

        /* Style the "About Me" section */
        .dark-mode #about {
            background-color: #1f0a32; /* Darker purple background */
        }

        /* Style the project cards with a different color (darker purple) */
        .dark-mode .project {
            background-color: #1f0a32; /* Darker purple background */
        }


        /* Style the project title */
        .dark-mode .project h2 {
            color: #fff; /* White text color */
        }


        /* Style the contact info section */
        .dark-mode #contact-info {
            background-color: #1f0a32; /* Darker purple background */
        }


        /* Link styles for dark-mode class */
        .dark-mode a {
            color: #b3b3f3; /* New text color for links with dark-mode class */
        }

        /* dark mode bar style*/
        .dark-mode hr {
            border-top: 1px solid #b3b3f3;
        }

        hr {
            border-top: 1px solid #333; /* Dark text color */
        }

        /* Dark Mode/Light Mode Button Styles */
        .dark-mode button.dark-mode-btn {
            background-color: #f5f2e9; /* Light sandy background*/
            color: #000; /* black text color */
        }

        /* Dark Mode/Light Mode Button Styles */
        button.dark-mode-btn {
            background-color: #2a2253; /* Dark purple background */
            color: #fff; /* White text color */
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
        }

        /* Reset some default browser styles */
        body, h1, h2, p {
            margin: 0;
            padding: 0;
        }

        /* Light Sandy Theme Styles */
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f2e9; /* Light sandy background */
            color: #333; /* Dark text color */
            line-height: 1.6;
            margin: 0;
            padding: 0;
            transition: background 0.2s linear;
        }

        /* Style the navigation menu with dark text on a light sandy background */
        nav {
            background-color: #d3c0a3; /* Light sandy background for the navbar */
            text-align: center;
            padding: 10px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            transition: background 0.2s linear;

        }

        /* Style the navbar links with larger size and wider spacing */
        nav a {
            display: inline-block;
            padding: 15px 40px;
            margin: 0 20px;
            font-size: 18px;
            color: #333; /* Dark text color */
            text-decoration: none;
        }

        /* Style the header with a sandy background and dark text */
        header {
            background-color: #d3c0a3; /* Light sandy background for the header */
            color: #333; /* Dark text color */
            padding: 20px;
            text-align: center;
            transition: background 0.2s linear;

        }

        /* Style the "About Me" section */
        #about {
            background-color: #e1d8c4; /* Lighter sandy background for "About Me" section */
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin: 20px;
            padding: 20px;
            transition: background 0.2s linear;


        }

        /* CSS for text with a maximum width before wrapping */
        .text-container {
            max-width: 800px; /* Adjust the maximum width as needed */
            word-wrap: normal; /* Prevents word breaking */
            position: relative;
            /*stop text overflow*/
            overflow: hidden;
        }


        /* Style the project cards with a sandy background */
        .project {
            background-color: #e1d8c4; /* Lighter sandy background for project cards */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            width: 100%;
            padding: 10px;
            transition: background 0.2s linear;

        }

        .dark-mode .gradient-button {
            background: linear-gradient(to bottom, rgba(31, 10, 50, 0.6), rgba(31, 10, 50, 1));
            color: #b09b71;
            transition: background 0.2s linear;
        }

        .dark-mode .gradient-button:hover {
            background: linear-gradient(to bottom, rgba(31, 10, 50, 0.3), rgba(31, 10, 50, 1));
            color: white;
            transition: background 0.2s linear;
        }

        .gradient-button {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to bottom, rgba(225, 216, 196, 0.6), rgba(225, 216, 196, 1));
            border: none;
            color: #572579;
            padding: 0;
            margin: 0;
            cursor: pointer;
            text-align: left;
            z-index: 2; /* Set a higher z-index to make sure the button is displayed in front */
            transition: background 0.2s linear;
        }

        .gradient-button:hover {
            background: linear-gradient(to bottom, rgba(225, 216, 196, 0.3), rgba(225, 216, 196, 1));
            color: black;
            transition: background 0.2s linear;

        }

        .gradient-button:focus {
            outline: 2px solid #AAAAAA;

        }

        img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
        }

        /* Style the project video */

        .project video {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
        }

        /* Style the project title */

        .project h2 {
            font-size: 24px;
            margin-top: 10px;
            color: #333; /* Dark text color */
        }

        /* Style the project description */

        .project p {
            font-size: 16px;
            margin-top: 10px;
        }

        /* Style the contact info section */

        #contact-info {
            background-color: #e1d8c4; /* Lighter sandy background for contact info */
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin: 20px;
            padding: 20px;
        }

        /* Add responsiveness for smaller screens */
        @media (max-width: 768px) {
            nav a {
                padding: 1px 4px; /* Larger padding and wider spacing */
                margin: 7px 4px; /* Wider spacing */
                font-size: 18px; /* Larger font size */
            }


        }

        .custom-padding {
            padding: 10px;
        }


    </style>
    <script>
        // Function to toggle between dark mode and light mode
        function toggleDarkMode() {
            const body = document.body;
            if (body.classList.contains('dark-mode')) {
                body.classList.remove('dark-mode');
                //change the button text
                document.querySelector('.dark-mode-btn').innerHTML = 'Dark Mode';
                //store the theme selection in the browser's local storage
                localStorage.setItem('theme', 'light');
            } else {
                body.classList.add('dark-mode');
                //change the button text
                document.querySelector('.dark-mode-btn').innerHTML = 'Light Mode';
                //store the theme selection in the browser's local storage
                localStorage.setItem('theme', 'dark');
            }
        }

        //function to scroll to a section with a sticky navbar
        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                const navHeight = document.querySelector('nav').offsetHeight;
                const offset = -navHeight; // Use the nav height as the offset
                const sectionTop = section.offsetTop + offset;
                window.scrollTo({
                    top: sectionTop,
                    behavior: 'smooth'
                });
            }
        }

        function expand(id) {
            //if the offsetwidth/2 is more than the height, the div can never be collapsed, so delete the button and the brs
            if (document.getElementById(id).offsetWidth / 4 > document.getElementById(id).scrollHeight - 10) {
                document.getElementById(id).querySelector('.gradient-button').remove();
                document.getElementById(id).querySelector('br').remove();
                // set the min height to document.offsetWidth/4
                document.getElementById(id).style.minHeight = document.getElementById(id).offsetWidth / 4 + "px";
                return;
            }
            let expandableDiv = document.getElementById(id);
            if (expandableDiv.style.maxHeight != expandableDiv.offsetWidth / 4 + "px") {
                let previousHeight = expandableDiv.scrollHeight; // Store the previous height
                expandableDiv.style.maxHeight = expandableDiv.offsetWidth / 4 + "px";
                window.scrollBy(0, expandableDiv.offsetWidth / 4 - previousHeight);
                document.getElementById(id).querySelector('.gradient-button').innerHTML = 'read more';
                //make button text bold
                document.getElementById(id).querySelector('.gradient-button').style.fontWeight = 'bold';
            } else {
                expandableDiv.style.maxHeight = "1000px";
                //change the button text for this specific button
                document.getElementById(id).querySelector('.gradient-button').innerHTML = 'read less';
                //make button text bold
                document.getElementById(id).querySelector('.gradient-button').style.fontWeight = 'bold';
            }


        }
    </script>
</head>
<body>
<nav>
    <a href="javascript:void(0);" onclick="scrollToSection('about')">About Me</a>
    <a href="javascript:void(0);" onclick="scrollToSection('projects')">Projects</a>
    <a href="javascript:void(0);" onclick="scrollToSection('contact-info')">Contact</a>
    <a href="CV.pdf" target="_blank">Download CV (PDF)</a>
</nav>
<header>
    <h1>Welcome to Thomas Chernaik's Portfolio</h1>
    <button class="dark-mode-btn" onclick="toggleDarkMode()">Dark Mode</button>
</header>
<section id="about">
    <h2>About Me</h2>
    <p class="text-container">First year PhD candidate at the University of Leeds, supervisor Markus Billeter. Researching modelling complex structures on the boundary between micro- and macro-scale (e.g. tree bark) for real time rendering (video games).
    </p>
</section>
<section id="projects">
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video height="405" style="width: auto; max-height: 405px;" poster="vulkan.png">
                                                <source src="vulkan.mp4" muted playsinline type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>Vulkan renderer</h2>
                    <div id="vulk" class="text-container">
                        As part of my advanced rendering module, I implemented a renderer in Vulkan and C++, with
                        various
                        features. First, I implemented a basic renderer, which could render a single triangle. Simply rendering one triangle with Vulkan involves using lots of
                        different components of the  Vulkan API. Once I had that one triangle, I could the progress to
                        rendering a scene (Sun temple), and allowing the camera to move about with standard wasd
                        controls.
                        I then implemented PBR shading and alpha masking for the leaves on the trees, as well as a few
                        simple debug views such as a depth view and a mip map view. I then implemented a version which
                        used a naive deferred pipeline, before moving on to add shadow mapping, a post process bloom
                        effect using a separable gaussian filter, and normal mapping. I also implemented a couple more
                        debug views - overshading and mesh density. The hardest part of this project, apart from
                        wrangling with  Vulkan synchronisation problems, was the shadow mapping. Implementing a shadowmap
                        for a single light was ok, but I wanted the ability to have many lights which cast shadows, and
                        managing all the resources while keeping everything synchronised was a challenge, but not one
                        that I couldn't overcome. I had a lot of fun making this and I hope to come back to it and add
                        more features in the future.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('vulk')">read more</button>
                    </div>
                    <hr class="rounded">
                    <p>
                        Source code available on request.
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video width="720" height="auto" muted playsinline poster="gaussianFootage.png">
                        <source src="gaussianFootage.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>Gaussian Splatting Rasteriser</h2>
                    <div id="gauss" class="text-container">
                        Gaussian splatting for radiance field rendering is a modern technique for rendering scenes, with
                        benefits including the ability to convert from directly from a real video to a splatting scene,
                        and alias-free rendering.
                        I first read the paper on this technique in 2023, and decided to implement a renderer in C++ and
                        OpenGL for my final year project at university.
                        In order to acheive remotely real-time performance, the entire scene is rendered in a series of
                        compute shaders, set up in a pipeline of my design.
                        I implemented a sorting pass, which required a GPU-based radix sort, as well as a pass to
                        project the splats, and a pass to render the splats.
                        You can read my full report, which includes a literature review, a description of the
                        implementation, and a discussion of the results, <a href="project.pdf" target="_blank">here</a>.
                        My implementation was able to render a scene with 100,000 splats at >30fps on AMD integrated
                        graphics, and I achieved a first class grade for this project.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('gauss')">read more</button>
                    </div>
                    <hr class="rounded">
                    <p>
                        You can find the source code <a
                            href="https://github.com/thomas-chernaik/OpenGLGaussianSplattingRenderer"
                            target="_blank">here</a>.
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video height="405" style="width: auto; max-height: 405px;" muted playsinline poster="doom.png">
                        <source src="doom.webm" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>Dodecahedra of doom</h2>
                    <div id="doom" class="text-container">
                        This project involved two main parts. The first was to implement a skeletal animation system,
                        taking bvh files, and using them to animate a running skeleton. This involved taking the
                        animation data, using it to pose the skeleton correctly, and updating the pose used as the
                        character runs, and blending between animations when the character starts and stops.
                        <br>
                        The second part was to implement a simple physics engine, which could handle collisions between
                        spheres at first, then moving on to a more complex (and spinnable) mesh of a dodecahedron.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('raytrace')">read more</button>
                    </div>
                    <hr class="rounded">
                    <p>
                        Source code available on request.
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video width="720" height="auto" muted playsinline poster="mesh.png">
                        <source src="hamishslow.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>Mesh processing toolkit</h2>
                    <div id="mesh" class="text-container">
                        For a university project, I implemented a mesh processing toolkit in C++.
                        <br>
                        There were several features:
                        <ul>
                            <li>Conversion from triangle soup to indexed face</li>
                            <li>Conversion from indexed face to directed edge</li>
                            <li>Manifold testing for meshes, including robust triangle-triangle intersection</li>
                            <li>Topological analysis using Euler's formula</li>
                            <li>Mesh repair</li>
                            <li>Mesh simplification using curvature analysis</li>
                        </ul>
                        It was a fun coursework, with a few interesting challenges. The first challenge is making a
                        triangle-triangle intersection test that is robust for this purpose. General methods are for
                        real time applications (such as physics), and don't have suitable precision for this. Exploring
                        different techniques to make it more robust was very interesting.
                        The second challenge was trying to get the mesh repair to work for more complex cases. There are
                        cases where it seems obvious to a human how a mesh should be repaired, but it is difficult to
                        describe this repair as a general purpose algorithm. It was fun coming up with ways to overcome
                        this. I received 98% for this coursework.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('mesh')">read more</button>
                    </div>
                    <hr class="rounded">
                    <p>
                        You can find the source code <a
                            href="https://github.com/thomas-chernaik/Mesh-processing-toolkit"
                            target="_blank">here</a>.
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video height="405" style="width: auto; max-height: 405px;" muted playsinline poster="raytrace.png">
                        <source src="raytrace.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>NEE Pathtracer</h2>
                    <div id="raytrace" class="text-container">
                        This project involved implementing, first a raytracer, then a monte carlo pathtracer in C++. It
                        was a fun project, and I implemented the following features for it:
                        <ul>
                            <li>Ray-triangle intersection</li>
                            <li>PBR phong shading model</li>
                            <li>Monte carlo path tracing</li>
                            <li>Refraction</li>
                            <li>Reflection</li>
                            <li>Soft shadows</li>
                            <li>Anti aliasing</li>
                            <li>Importance sampling using next event estimation</li>
                            <li>Fresnel</li>
                        </ul>
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('raytrace')">read more</button>
                    </div>
                    <hr class="rounded">
                    <p>
                        Source code available on request.
                    </p>
                </div>
            </div>



            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video width="720" height="auto" muted playsinline poster="rocketFootage.png">
                        <source src="rocketFootage.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>Rocket Demo</h2>
                    <div id="rock" class="text-container">
                        The second coursework for my computer graphics module was to create a rocket demo in OpenGL,
                        where the rocket could be triggered to launch.
                        This was a group project, and I was responsible for the base rendering, particle system, UI
                        system, and animation system.
                        The particle system was implemented using batch rendering, and the particles were rendered as
                        untextured quads. I achieved performance of over 60fps with 2,000,000 particles by optimising
                        the particle system to have as little computation as possible.
                        The paths of each particle were pre-calculated, and the particles were rendered in a single draw
                        call, with the location of each particle updated in the vertex shader with some simple
                        interpolation of the path, based on the current time.
                        The UI system was implemented using 2 custom classes I made, one for the text and one for the
                        buttons. They both had negligible performance impact, and were implemented such that it was easy
                        to add new buttons and text.
                        The animation system was implemented by defining a mathematical function for the rocket to
                        follow, and then interpolating the rocket's position and rotation based on the current time.
                        This made it easy to reset and restart the rocket whenever wanted.
                        The base rendering uses standard OpenGL techniques, such as VAOs, VBOs, and shaders, and a
                        custom shader for each model, which allowed for real time lighting.
                        The rocket demo was a great success, and I achieved a mark of 90% for this coursework.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('rock')">read more</button>
                    </div>
                    <hr class="rounded">
                    <p>
                        Source code available on request.
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video width="720" height="auto" muted playsinline poster="scribblesFootage.png">
                        <source src="scribblesFootage.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>Scribbles</h2>
                    <div id="scribbles" class="text-container">Six second scribbles is a great card game which you
                        should get to play
                        with your family and friends.
                        Unfortunately, my friends are living abroad this year, so I decided to make a web version of the
                        game so we could play together.
                        I used the python Flask library for this, as I was familiar with it from more than one past
                        project. I used the flask-socketio library
                        to handle the websockets, which I had not used before. I used the javascript library socket.io
                        to handle the websockets on the client side.
                        I used bootstrap to make the website look nice. I wanted the server to be able to handle
                        multiple games at once, so I implemented a lobby system.
                        One player would create a lobby, and then other players could join via a code. The players could
                        then vote to start the game, which was communicated via websockets.
                        There were many cards to type up from the card game, so I made a little website interface to
                        type up the cards, which would then be saved to a file.
                        In a game, players would make a drawing, which would be sent to the server, and then sent to the
                        other players. The other players would then have to guess what the drawing was.
                        I stored the images using a custom class I made which implemented pickling, and cleaned up the
                        images after a certain time, and when a new round started.
                        I deployed this project to azure, but it is no longer on there, as my student account expired. I
                        have a private deployment I can use with friends, but I won't link here.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('scribbles')">read more</button>
                    </div>
                    <hr class="rounded">
                    <p>
                        You can find the source code <a href="https://github.com/thomas-chernaik/sixsecondscribbles"
                                                        target="_blank">here</a>.
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video width="720" height="auto" muted playsinline poster="chessFootage.png">
                        <source src="chessFootage.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>Chess</h2>
                    <div id="chess" class="text-container">
                        This was a project I did a while ago to improve my C++ skills. I wanted to make a project that would test my
                        knowledge, and hopefully provide
                        some learning experiences. I also wanted to make a game on a lower level than I had before, so I
                        decided to make a chess game.
                        I had used the QT library before for a university project, but I wanted to work at a lower
                        level, so I decided to use the SDL2 library.
                        I used the SDL2 library to create a window, and to handle input. I used the SDL2_image library
                        to load images for the chess pieces.
                        I implemented the game logic using some OO principles. It was in my mind while I was making it
                        that I would want to make a chess AI at some point,
                        so I made sure to keep the game logic, input handling, and rendering separate. I also had a way
                        to store game states, so I could look ahead easily.
                        Memory had to be dynamically allocated for the game states, so I used smart pointers to make
                        sure that memory was freed when it was no longer needed.
                        I have done several C projects, especially at university, so I was very familiar with using raw
                        pointers to manage memory, but I wanted to use smart pointers
                        to practice using them. I also implemented a feature to save and load from a file in the
                        Forsyth–Edwards Notation (FEN) format, which is a standard format
                        for chess states. I used this feature to test the game logic. I found that there was no need to
                        implement checkmate, as the game logic I had implemented
                        already handled it, as player where unable to make moves that would put them in checkmate, so
                        when checkmate happened, a player would be unable to make a move.
                        I implemented a feature to highlight the squares that a piece could move to, which was very
                        useful for testing the game logic. In the future, I will make a chess AI
                        using the minimax algorithm, and I will use the game logic I have already implemented.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('chess')">read more</button>
                    </div>
                    <hr class="solid">
                    <p>
                        You can find the source code <a href="https://github.com/thomas-chernaik/chess" target="_blank">here</a>.
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video id="delvvid" width="720" height="auto" muted playsinline poster="deliveriesFootage.png">
                        <source src="deliveriesFootage.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>We suck at deliveries</h2>
                    <div id="delv" class="text-container">I competed in Ludum Dare 53, my first game jam. The theme was
                        delivery,
                        and there was a game I
                        had wanted to make for a while which could be made as a delivery game. It was inspired by the
                        car in the level select
                        menu in the overcooked games, and came out very nicely. I made the game with one other person,
                        and I contributed a lot of the gameplay code for this project, as well as
                        some of the 3D art. I modeled the van and the pallets in Blender. I programmed a lightweight
                        custom physics engine that allowed us
                        to calculate collisions our van took with the environment without dealing with Unity's built-in
                        physics engine. I also programmed the
                        package distribution system. This involved keeping track of "collectors" and "spawners", where
                        the collectors are houses the player
                        must deliver packages to, and the spawners are the shops where the packages spawn in. For each
                        package spawned, there must be a house which expects
                        a package. Additionally, we had to keep track of packages that hadn't been delivered in a
                        certain amount of time, so we could call the player out.
                        All of the magic numbers involved here were put onto nice easily adjustable public variables, so
                        we could easily tweak the gameplay, and speed up
                        gameplay for what little testing we had time for.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('delv')">read more</button>
                    </div>
                    <hr class="solid">
                    <p>
                        You can find the ludum dare submission <a
                            href="https://ldjam.com/events/ludum-dare/53/we-suck-at-deliveries"
                            target="_blank">here</a>, and you can play the game jam version of the game <a
                            href="https://thomas-chernaik.github.io/delv" target="_blank">here</a>.
                    </p>
                </div>
            </div>


            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <img src="flashcard.png" alt="Placeholder Image" width="720" height="auto">
                    <h2>Flashcards</h2>
                    <div id="flash" class="text-container">I took part in the great uni hack in late 2022. This
                        was a great experience, where we created a full stack application in 24 hours.
                        I worked with two other people, and we created a flashcard application, which would generate
                        flashcards from your notes.
                        About 8 months later, Quizlet released a feature which did exactly this, and we are looking to
                        release a full version of our application soon.
                        We used the python library flask for the backend, and wrote the frontend using node.js. This was
                        before ChatGPT came out, so we used
                        an LLM called Cohere to generate the flashcards. I worked on the backend, and implemented some
                        of the database functionality, as well as
                        some of the endpoints. I also worked with the LLM, and implemented some of the code to generate
                        the flashcards.
                        I am still currently working on this project, and we have changed some of our infrastructure,
                        such as moving to nosql from SQLite, and
                        moving to use chatgpt. My work currently has been on improving response times on the backend, and
                        researching
                        implementing a subscription system.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('flash')">read more</button>
                    </div>
                    <hr class="solid">
                    <p>
                        You can find the Hackathon version of the source code <a
                            href="http://github.com/thomas-chernaik/pentatonicSquashed" target="_blank">here</a>.
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video height="405" style="width: auto; max-height: 405px;" muted playsinline poster="GrassFootage.png">
                        <source src="GrassFootage.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>Procedural Grass</h2>
                    <div id="grass" class="text-container">For this project I wanted to make grass similar to how grass
                        works in some
                        AAA games,
                        using real geometry for
                        each blade.
                        There are two stages to the grass generation. The first stage is in a compute shader which
                        calculates a
                        location and rotation for each blade.
                        Then a stage in the surface shader calculates sway, lighting, colour, and if the blade is
                        flattened by an
                        object.
                        The final result is optimized enough that it runs at over 100 fps with 500000 visible blades,
                        which I am
                        very happy with.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('grass')">read more</button>
                    </div>
                    <hr class="solid">
                    <p>You can find the full source code
                        <a href="https://github.com/thomas-chernaik/ProceduralGrass"
                           target=_blank">here</a>
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video width="720" height="auto" muted playsinline poster="FABRIKFootage.png">
                        <source src="FABRIKFootage.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>FABRIK</h2>
                    <div id="fabrik" class="text-container"> Following the procedural animation project, I decided to create my own FABRIK implementation
                        for
                        unity, having initially used another implementation.
                        I then tested the FABRIK implementation with a simple procedurally animated cat.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('fabrik')">read more</button>
                    </div>
                    <hr class="solid">
                    <p>You can find the full source code
                        <a href="https://github.com/thomas-chernaik/FABRIK"
                           target="_blank">here</a>
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video width="720" height="auto" muted playsinline poster="monsterFootage.png">
                        <source src="monsterFootage.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>Procedural Animation</h2>
                    <div id="anim" class="text-container"> To further my interest in procedural animation I decided to
                        design a
                        project which
                        would develop the skillset. This took the form of a procedurally animated
                        "tentacle monster" which can move around with convincing animation. I calculate new feet
                        positions randomly
                        in the direction of velocity so
                        that a minimum number of tentacles are always in spawn. When feet reach a certain distance from
                        the centre,
                        they despawn, leading to new ones spawing.
                        In order to have the tentacles convincingly spawn and despawn, I made a script to shrink the
                        mesh. This is
                        in the form of a compute shader which
                        clips the mesh down to the required size. By the end of my project I had produced a
                        monster-character with
                        convincing animation that can be player controlled.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('anim')">read more</button>
                    </div>
                    <hr class="solid">
                    <p>You can find the full source code
                        <a href="https://github.com/thomas-chernaik/tendrilMonster"
                           target="_blank">here</a>
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video width="720" height="auto" muted playsinline poster="p2pmpFootage.png">
                        <source src="p2pmpFootage.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>Peer to Peer multiplayer</h2>
                    <div id="multi" class="text-container"> I set myself the challenge of designing a simple multiplayer
                        system, as multiplayer is part of
                        many of the biggest modern games.
                        I wanted to use a udp peer to peer system, as this would require me to write code to communicate
                        over the internet, but wouldn't require usage of external hosting.
                        In the end, I successfully completed a peer to peer system in unity, as you can see in the video
                        before
                        where the two clients communicate across the local network. The black cube is controlled by the
                        left client and the white cube is controlled by the right client
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('multi')">read more</button>
                    </div>
                    <hr class="solid">
                    <p>You can find the full source code
                        <a href="https://github.com/thomas-chernaik/p2punitymultiplayer" target="_blank">here</a>
                    </p>
                </div>
            </div>
            <div class="col-md-6 col-sm-12 custom-padding">
                <div class="project">
                    <video width="720" height="auto" muted playsinline poster="slimeFootage.png">
                        <source src="slimeFootage.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <h2>Slime mould simulation</h2>
                    <div id="spore" class="text-container">I began this project after watching this <a
                            href="https://www.youtube.com/watch?v=X-iSQQgOd1A&t=936s">youtube video in which a similar
                        project is made.</a>
                        This project was where I learned how to use HLSL and compute shaders for the first time.
                        There are two main steps: A step in which the direction of each spore is calculated, and a step
                        in which
                        the trails of the spores diffuse. Once I implemented these, I added the ability to influence the
                        patterns
                        of the spores with an image.
                        <br>
                        <br>
                        <button class="gradient-button" onclick="expand('spore')">read more</button>
                    </div>
                    <hr class="solid">
                    <p>You can find the full source code
                        <a href="https://github.com/thomas-chernaik/SlimeMould" target="_blank">here</a>
                    </p>
                </div>
            </div>


        </div>
    </div>
</section>
<section id="contact-info">
    <h2>Contact Information</h2>
    <p>Email: thomas.chernaik@gmail.com</p>
    <p>Phone: +447486409343</p>
    <p>LinkedIn: <a href="https://www.linkedin.com/in/thomas-chernaik-611aa7226/" target="_blank">linkedin/thomas-chernaik-611aa7226/</a>
    </p>
    <p>GitHub: <a href="https://github.com/thomas-chernaik" target="_blank">github/thomas-chernaik</a></p>
</section>
<script>
    // Check for saved theme choice and apply it (default dark)
    const theme = localStorage.getItem('theme');
    if (theme) {
        if (theme === 'dark') {
            toggleDarkMode();
        }
    } else {
        toggleDarkMode();
    }
    //check if the screen is wide, and move the dark mode button to the navbar if it is
    if (window.matchMedia("(min-width: 768px)").matches) {
        const darkModeBtn = document.querySelector('.dark-mode-btn');
        const nav = document.querySelector('nav');
        nav.appendChild(darkModeBtn);
    }

    projectsIDs = [
        "fabrik",
        "mesh",
        "vulk",
        "gauss",
        "rock",
        "chess",
        "scribbles",
        "delv",
        "flash",
        "grass",
        "anim",
        "multi",
        "spore",
        "raytrace",
        "doom",
    ]
    //for each projectID, call expand on it
    projectsIDs.forEach(id => {
        expand(id);
    });

    document.addEventListener('DOMContentLoaded', function () {
        const videos = document.querySelectorAll('video');

        function playVideoOnScroll() {
            videos.forEach(video => {
                const rect = video.getBoundingClientRect();
                if (rect.top >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)) {
                    video.play();
                    // if the id of the video is delvvid, then skip to 9 seconds
                    if (video.id === 'delvvid' && video.currentTime < 9) {
                        video.currentTime = 9;
                    }
                    // add the class "playing" to the video
                    video.classList.add('playing');
                }
            });
        }

        window.addEventListener('scroll', playVideoOnScroll);
        playVideoOnScroll(); // Initial check in case any video is already in the viewport


        // add an event listener to restart the video when finished
        videos.forEach(video => {
            video.addEventListener('ended', function () {
                // can just use the playonScroll function to play the video again
                playVideoOnScroll();
            });
        });


    });

    document.addEventListener('DOMContentLoaded', function () {
        const videos = document.querySelectorAll('video');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (!entry.isIntersecting) {
                    entry.target.pause();
                }
            });
        }, {threshold: 0.1});

        videos.forEach(video => {
            observer.observe(video);
        });
    });
    document.addEventListener('DOMContentLoaded', function () {
        const skipVideo = document.getElementById('skipVideo');

        skipVideo.addEventListener('play', function () {
            if (skipVideo.currentTime < 9) {
                skipVideo.currentTime = 9;
            }
        });
    });
</script>
</body>
</html>
